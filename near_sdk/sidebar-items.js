window.SIDEBAR_ITEMS = {"attr":[["ext_contract","`ext_contract` takes a Rust Trait and converts it to a module with static methods. Each of these static methods takes positional arguments defined by the Trait, then the receiver_id, the attached deposit and the amount of gas and returns a new Promise."],["near_bindgen","This attribute macro is used on a struct and its implementations to generate the necessary code to expose `pub` methods from the contract as well as generating the glue code to be a valid NEAR contract."]],"constant":[["ONE_NEAR","Balance of one NEAR, which is 10^24 Yocto NEAR."],["ONE_YOCTO","Balance of one Yocto NEAR, which is the smallest denomination. This value is 10^-24 of one NEAR."]],"derive":[["BorshStorageKey","`BorshStorageKey` generates implementation for `BorshIntoStorageKey` trait. It allows the type to be passed as a unique prefix for persistent collections. The type should also implement or derive `BorshSerialize` trait."],["FunctionError","`FunctionError` generates implementation for `near_sdk::FunctionError` trait. It allows contract runtime to panic with the type using its `ToString` implementation as the message."],["PanicOnDefault","`PanicOnDefault` generates implementation for `Default` trait that panics with the following message `The contract is not initialized` when `default()` is called. This is a helpful macro in case the contract is required to be initialized with either `init` or `init(ignore_state)`."]],"enum":[["CurveType","PublicKey curve"],["PromiseError","All error variants which can occur with promise results."],["PromiseOrValue","When the method can return either a promise or a value, it can be called with `PromiseOrValue::Promise` or `PromiseOrValue::Value` to specify which one should be returned."],["PromiseResult","When there is a callback attached to one or more contract calls the execution results of these calls are available to the contract invoked through the callback."],["ReturnData",""],["VmPromiseResult","When there is a callback attached to one or more contract calls the execution results of these calls are available to the contract invoked through the callback."]],"macro":[["log","Helper macro to log a message through `env::log_str`. This macro can be used similar to the [`std::format`] macro in most cases."],["metadata","`metadata` generates the metadata method and should be placed at the very end of the `lib.rs` file."],["require","Helper macro to create assertions that will panic through the runtime host functions."],["setup_alloc","Deprecated helper function which used to generate code to initialize the `GlobalAllocator`. This is now initialized by default. Disable `wee_alloc` feature to configure manually."],["testing_env","Initializes a testing environment to mock interactions which would otherwise go through a validator node. This macro will initialize or overwrite the `MockedBlockchain` instance for interactions from a smart contract."]],"mod":[["collections","Collections that offer an alternative to standard containers from `std::collections::*` by utilizing the underlying blockchain trie storage more efficiently."],["env","Blockchain-specific methods available to the smart contract. This is a wrapper around a low-level `BlockchainInterface`. Unless you know what you are doing prefer using `env::*` whenever possible. In case of cross-contract calls prefer using even higher-level API available through `callback_args`, `callback_args_vec`, `ext_contract`, `Promise`, and `PromiseOrValue`."],["json_types","Helper types for JSON serialization."],["mock","Mock blockchain utilities. These can only be used inside tests and are not available for a wasm32 target."],["test_utils","Testing blockchain utilities. These can only be used inside tests and are not available for a wasm32 target."],["utils","Helper methods that often used in smart contracts."]],"struct":[["Abort","A simple type used in conjunction with [FunctionError] representing that the function should abort without a custom message."],["AccountId","Account identifier. This is the human readable utf8 string which is used internally to index accounts on the network and their respective state."],["Gas","Represents the amount of NEAR tokens in “gas units” which are used to fund transactions."],["GasWeight","Weight of unused gas to use with `promise_batch_action_function_call_weight`."],["MockedBlockchain","Mocked blockchain that can be used in the tests for the smart contracts. It implements `BlockchainInterface` by redirecting calls to `VMLogic`. It unwraps errors of `VMLogic` to cause panic during the unit tests similarly to how errors of `VMLogic` would cause the termination of guest program execution. Unit tests can even assert the expected error message."],["ParseAccountIdError",""],["Promise","A structure representing a result of the scheduled execution on another contract."],["PublicKey","Public key in a binary format with base58 string serialization with human-readable curve. The key types currently supported are `secp256k1` and `ed25519`."],["RuntimeFeesConfig",""],["VMConfig",""],["VMContext","Context for the contract execution."]],"trait":[["FunctionError","Enables contract runtime to panic with the given type. Any error type used in conjunction with `#[handle_result]` has to implement this trait."],["IntoStorageKey","Converts Self into a [`Vec<u8>`] that is used for a storage key through `into_storage_key`."]],"type":[["Balance","Balance is a type for storing amounts of tokens, specified in yoctoNEAR."],["BlockHeight","Height of the block."],["BlockHeightDelta","Block height delta that measures the difference between `BlockHeight`s."],["CryptoHash","Raw type for 32 bytes of the hash."],["Duration","Raw type for duration in nanoseconds"],["EpochHeight","Height of the epoch."],["GCCount",""],["IteratorIndex",""],["MerkleHash","Hash used by a struct implementing the Merkle tree."],["Nonce","Nonce for transactions."],["NumBlocks","Number of blocks in current group."],["NumSeats","Number of seats of validators (block producer or hidden ones) in current group (settlement)."],["NumShards","Number of shards in current group."],["PromiseId",""],["PromiseIndex","Promise index that is computed only once."],["ProtocolVersion",""],["ReceiptIndex","An index of Receipt to append an action"],["ShardId","Shard index, from 0 to NUM_SHARDS - 1."],["StorageUsage","StorageUsage is used to count the amount of storage used by a contract."],["StorageUsageChange","StorageUsageChange is used to count the storage usage within a single contract call."],["Timestamp","Raw type for timestamp in nanoseconds"],["ValidatorId","Validator identifier in current group."],["ValidatorMask","Mask which validators participated in multi sign."]]};